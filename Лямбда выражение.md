[[Функции в котлин]]
# Лямбды - это "функциональный литерал" 


Она получила свое название от **лямбда-исчисления** Алонзо Черча, в котором все функции анонимны. Лямбда также является синонимом **замыкания** (closures).


Замыкания названы так потому, что они могут «закрывать» переменные и константы в пределах собственной **области видимости**? т.е в их область видимости не нужно передавать аргументы.


Они видят все, что есть в той области, в которой они были вызваны. 

Лямбда выражения можно присвоить переменной.
```Kotlin
var lambda: () -> Unit

val lambda = {print("Hello world!")}

```
Написав `val` лямбда выражение стало объектом, теперь мы можем его запихнуть в какую-либо функцию, либо вызвать

```Kotlin 
val lambda = {print("Hello world")}
lambda.invoke() //Инициализируем вызов лямбды
```



### Лямбда в качестве аргемента для функии 

Рассмотрим следующий код 

```Kotlin 
fun operateTwoNumbers(a:Int,
					  b:Int,
					  operation:(Int, Int)->Int):Int{
	return operation(a,b)
}
```

Мы создали фунцию, которая берет 3 аргументом лямбда выражение (На самом деле, она просто берет 3 аргементом любую функцию, а лямбда-выражение - это функция без имени), т.е возможно и такое:
```Kotlin
fun addFunction(a: Int, b:Int) = a + b

operateTwoNumbers(1, 2, ::addFunction)
```
Оператор `::` является ссылочным типом, который просто говорит коду найти функцию с этим именем в текущей области видимости 


#### Теперь мы можем передать в эту функцию лямбду, но несколькими способами

1)  Инициализировав лямбда функцию в переменную:
```Kotlin
val lambda:(Int,Int)->Int = {a:Int, b:Int -> a+b}

operateTwoNumbers(1, 2, lambda)
```

2) Можно объявить лямбду прямо там, куда вы хотите ее передать 
```Kotlin
operateTwoNumbers(1, 2, {a:Int, b:Int -> a + b})
```

Упростить синтаксис можно удалив шаблонный код
```Kotlin
operateTwoNumbers(1, 2, {a,b -> a + b})
```

Можно пойти дальше: 
Оператор `+`, является функцией  `plus()` класса `Int`, т.е мы можем передать нашу функцию 
```Kotlin
operateTwoNumbers(1, 2, Int::plus)
```

#### Если последний параметр функции является функцией, то лямбду можно просто передать вынося ее за круглые скобки 

```Kotlin
operateTwoNumbers(1, 2){a,b -> a + b}
```

Такой синтаксис также известен как  _trailing lambda_.

Также если функция является единственным параметром, то скобки можео и вовсе опустить
```Kotlin
object.run{ }
```







### Различия Лямбды и Анонимной функции 

1) **Необходимость определения возвращаемого типа** - Лямба-выражения выводят тип возвращаемого выражения самостоятельно, а в анонимной функции его нужно задать явно 
	```Kotlin
	//Анонимная функция
	val sum = fun (x: Int, y: Int): Int = x + y
	//Лямбда выражение	
	val sum = { x: Int, y: Int -> x + y }
	```

2) **Оператор `return`** - В лямбда выражении `return` сделает полный выход из функции, где была лямбда выражение, в то время как анонимная функции завержит только свое существование 

Пример:

**Лямбда выражение 
```Kotlin 
fun processElements(list: List<Element>): Boolean {
     list.forEach { element ->
          if (!element.process()) return false   //выход из функции processElements
     }
     return true
}
```

**Анонимная функция 
```Kotlin
fun processElements(list: List<Element>) {
    list.forEach(fun(element) { 
        if (!needToProcessElement(element)) return //Просто выход из блока 
        element.process()
    })
}
```

Для выхода Лямбдой из блока кода, но не из функции, нужно вызвать `return@label`

```Kotlin
fun processElements(list: List<Element>) {
     list.forEach { element ->
          if (!needToProcessElement(element)) return@forEach // returns from block
          element.process()
     }
}
```


### Ключевые особенности лямбды:

-   Лямбда является функцией без названия. Она может присваиваться переменной и передаваться как аргумент функции;
-   У лямбда-выражений есть **сокращенный синтаксис**, при помощи которого их намного легче использовать, чем другие функции;
-   Лямбда может захватить переменные и константы в собственной **области видимости**;
-   Лямбда может использоваться для сортировки коллекции;
-   Для коллекций существует удобный набор функций, которые можно использовать для итерации и преобразования коллекции. Под преобразованием подразумевается сопоставление каждого элемента с новым значением, фильтрацию определенных значений или сокращение коллекции до одного значения.