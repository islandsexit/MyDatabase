## Умное приведение типов 

В большинстве случаев вам не нужно использовать явные приведения в Kotlin, потому что компилятор отслеживает `is`-проверки и явные преобразования для неизменяемых значений и вставляет (безопасно) приведения автоматически, там, где они нужны.

```kotlin
fun demo(x: Any) {
    if (x is String) {
        print(x.length) // x автоматически преобразовывается в String
    }
}
```

**Ограничения умных преобразований

Они могут применяться только если компилятор точно знает, что данная переменная не была изменена в ходе проверки типа 
Для смарт преобразований есть 4 парвила:

-   с локальными `val` переменными - всегда за исключением локальных делегированных свойств (cм. [[Делегированные свойства]])
-   с `val` свойствами - если поле имеет модификатор доступа [[private]] или [[internal]], или проверка происходит в том же модуле (см. [[Пакет Package]]), в котором объявлено это свойство. Умные приведения неприменимы к публичным свойствам или свойствам, которые имеют переопределённые getter'ы;
-   с локальными `var` переменными - если переменная не изменяется между проверкой и использованием, не захватывается лямбдой, которая её модифицирует и не является локальным делегированным свойством;
-   с `var` свойствами - никогда, потому что переменная может быть изменена в любое время другим кодом

**Короткая сводка: Проще говоря, если хотите использовать смарт-перобразования, то полюбите тогда делать `val` все свойства и не меняйте [[get()]]
А вообще просто проверяйте соответсвие типов  [[Оператор is]] 

---

## Мануальное приведение типов 

С помощью оператора `as` мы можем явно указать тип переменной 

```kotlin
val strokaNoChislo:Int = 3

print(strokaNoChislo as String)
```

Или, к примеру мы хотим из типа `String?` получить `String`
```Kotlin
val stroka:String? = "Hello"

val hello:String = stroka as String
```

Вот только если мы инициализируем строку как null, то у нас выпадет [[NullPointerException]]
```kotlin
val stroka:String? = null

val hello:String = stroka as String
```

Чтоб такого не произошло, нам нужно использовать опретор безопасного приведения `as?`, которая, в случае неудачи даст нам null
```kotlin
val stroka:String? = null

val hello:String? = stroka as? String //output:null
```

Все это можно делать и со своими типами данных 

