## Модификатор lateinit

Модификатор **lateinit** говорит о том, что данная переменная будет инициализирована позже. При этом инициализировать свойство можно из любого места, откуда она видна.

Правила использования модификатора **lateinit**:

-   используется **только** совместно с ключевым словом **var**;
-   свойство может быть объявлено только внутри тела класса (не в основном конструкторе);
-   тип свойства не может быть нулевым и примитивным;
-   у свойства не должно быть пользовательских геттеров и сеттеров;

```kotlin
class Work

class Person {
  lateinit var work: Work

  fun init() {
    work = Work()
  }

}
```

---
### Причины почему лучше не использовать lateinit

**Но почему стоит избегать?** В основном из-за того, что `lateinit` часто используют неправильно.

Пример из андроида: у вас во фрагменте есть `lateinit`-переменная, которая инициализируется в `onCreateView`. А теперь по шагам:

-   Фрагмент создался.
-   Создалась `view` для фрагмента. В `lateinit`-переменную было сохранено значение из `view`.
-   Фрагмент ушел в backstack (например, был заменён на другой фрагмент). Вызывается метод [[onDestroyView]] (но не [[onDestroy]]), который уничтожит `view`, но не ссылку на него в `lateinit`-переменной.
-   При возвращении к фрагменту в `lateinit`-переменную присвоится новая ссылка на `view`, тогда как старый объект будет ещё какое-то время висеть в памяти.

Если эти шаги повторить, скажем, 10 раз подряд, то у вас в памяти будет висеть уже 10 бесполезных объектов, которые уничтожатся только с уничтожением самого фрагмента.

Поэтому используйте `lateinit` с осторожностью, чтобы потом не удивляться от возникновения неожиданных последствий.

В основном lateinit появился из-за того, что нужно делать инъекцию зависимостей (см. [[Инъекция зависимостей]]) в [[Dagger2]] 