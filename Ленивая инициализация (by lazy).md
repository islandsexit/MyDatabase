Помимо отложенной инициализации в Kotlin существует ленивая инициализация свойств. Такая инициализация осуществляется с помощью функции `lazy()`, которая принимает лямбду, а возвращает экземпляр класса `Lazy<T>`.

Данный объект реализует **ленивое** вычисление значения свойства: при первом обращении к свойству метод `get()` запускает лямбда-выражение (переданное `lazy()` в качестве аргумента) и запоминает полученное значение, а последующие вызовы просто возвращают запомненное значение.

```kotlin

class Person {
  val work: String by lazy {
    println("Start")
    "End"
  }

  fun main(args: Array<String>) {
    println(work)
    println(work)
  }

  // Код выведет:
  // Start
  // End
  // End
}
```

**Ленивая инициализация может быть только `val`

Свойство, инициализированное подобным образом, называется _делегированным свойством_ (см. [[Делегированные свойства]]) . Потому что мы делегировали вычисление значения классу-делегату `Lazy<T>`. Данный класс является частью стандартной библиотеки Kotlin и именно в нем реализован get-метод вычисляющий и возвращающий значение.

--- 
## Потокобезопасность

- По умолчанию вычисление ленивых свойств **синхронизировано**: значение вычисляется только в одном потоке (см. [[Thread (Поток)]] , а все остальные потоки могут видеть одно и то же значение. Однако способом вычисления можно управлять. Для этого функции `lazy()` нужно передать один из параметров:

-   `LazyThreadSafetyMode.SYNCHRONIZED` - режим по умолчанию, потокобезопасный.
-   `LazyThreadSafetyMode.PUBLICATION` - вычисление будет происходить в нескольких потоках, но вернётся то значение, которое будет вычислено первым.
-   `LazyThreadSafetyMode.NONE` - использовать с осторожностью, не является потокобезопасным. Нужно быть уверенным, что вычисление будет происходить в одном потоке.