
### Переопределение методов 

```kotlin
open class Shape {
    open fun draw() { /*...*/ }
    fun fill() { /*...*/ }
}

class Circle() : Shape() {
    override fun draw() { /*...*/ }
}
```

Для `Circle.draw()` необходим модификатор `override`. В случае её отсутствия компилятор выдаст ошибку. Если у функции типа `Shape.fill()` нет модификатора `open`, объявление метода с такой же сигнатурой в производном классе невозможно, с `override` или без. Модификатор `open` не действует при добавлении к членам final класса (т.е. класса без модификатора `open`).

Член класса, помеченный `override`, является сам по себе open, т.е. он может быть переопределён в производных классах. Если вы хотите запретить возможность переопределения такого члена, используйте `final`.

```kotlin
open class Rectangle() : Shape() {
    final override fun draw() { /*...*/ }
}
```
